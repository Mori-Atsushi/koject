"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[996],{5674:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"android-support","metadata":{"permalink":"/koject/blog/android-support","editUrl":"https://github.com/Mori-Atsushi/koject/tree/main/docs/blog/2023-03-11-android-support.mdx","source":"@site/blog/2023-03-11-android-support.mdx","title":"Koject v1.1.0 - Enhanced Android support","description":"I have released Koject v1.1.0, which includes enhanced support for Android application development.","date":"2023-03-11T00:00:00.000Z","formattedDate":"March 11, 2023","tags":[],"readingTime":3.145,"hasTruncateMarker":true,"authors":[{"name":"Mori Atsushi","title":"Koject owner","url":"https://github.com/Mori-Atsushi","imageURL":"https://github.com/mori-atsushi.png","key":"atsushi"}],"frontMatter":{"slug":"android-support","title":"Koject v1.1.0 - Enhanced Android support","authors":"atsushi","image":"/blog/2023-03-11/ogp.png"},"nextItem":{"title":"Hello, Koject v1.0.0","permalink":"/koject/blog/first-stable-release"}},"content":"import {\\n    Provides,\\n    Singleton,\\n    Inject,\\n    ViewModelComponent,\\n    ActivityInjectViewModels,\\n    FragmentInjectViewModels,\\n    RememberInject,\\n} from \'@site/src/components/CodeLink\';\\n\\n\\n![](/blog/2023-03-11/banner.png)\\n\\nI have released **Koject v1.1.0**, which includes enhanced support for Android application development.\\nIn this article, I will introduce the new features and the Component feature that enables the features.\\n\\n\x3c!--truncate--\x3e\\n\\n[**\u65e5\u672c\u8a9e\u3067\u8aad\u3080 \u2192**](/blog/jp/android-support)\\n\\n## Inject ViewModels\\nIn Android application development, it is common to add dependencies such as Repository to AndroidX\'s [ViewModel](https://developer.android.com/reference/androidx/lifecycle/ViewModel) and use it from Activity or Fragment. With Koject v1.1.0, you can automatically inject ViewModel dependencies.\\n\\nFirst, add the <Provides/> annotation to the class used in ViewModel and register it with the DI container.\\nBy adding <Singleton/>, it can register as a singleton.\\n\\n```kotlin\\n@Singleton\\n@Provides\\nclass UserRepository {\\n    /* ... */\\n}\\n\\n@Singleton\\n@Provides\\nclass ContentRepository {\\n    /* ... */\\n}\\n```\\n\\nNext, define the ViewModel.\\nYou can inject the classes registered with the DI container in the constructor. Add `@Provides` annotation and <ViewModelComponent/> annotation to ViewModel.\\n\\n```kotlin\\n@Provides\\n@ViewModelComponent\\nclass TopViewModel(\\n    private val userRepository: UserRepository,\\n    private val contentRepository: ContentRepository,\\n): ViewModel() {\\n    /* ... */\\n}\\n```\\n\\nFinally, use the <ActivityInjectViewModels/> function to obtain the ViewModel.\\n\\n```kotlin\\nclass TopActivity : ComponentActivity() {\\n    private val viewModel: TopViewModel by injectViewModels()\\n\\n    override fun onCreate(savedInstanceState: Bundle?) {\\n        super.onCreate(savedInstanceState)\\n        /* ... */\\n    }\\n}\\n```\\n\\nFor Fragment, please use the <FragmentInjectViewModels/> function instead.\\n\\n```kotlin\\nclass TopFragment : Fragment() {\\n    private val viewModel: TopViewModel by injectViewModels()\\n\\n    override fun onCreateView(\\n        inflater: LayoutInflater,\\n        container: ViewGroup?,\\n        savedInstanceState: Bundle?,\\n    ): View? {\\n        /* ... */\\n    }\\n}\\n```\\n\\nAdditional dependencies are required to use this feature. For more details, please refer to the [documentation](/docs/android/viewmodel).\\n\\n## Inject into Composable\\nKoject 1.1.0 also added support for [Jetpack Compose](https://developer.android.com/jetpack/compose) and [Compose Multiplatform](https://www.jetbrains.com/lp/compose-mpp/).\\n\\nYou can use the <RememberInject/> Composable function to use the provided class in a Composable function.\\n\\n```kotlin\\n@Composable\\nfun Sample(\\n    controller: SampleController = rememberInject()\\n) {\\n    /* ... */\\n}\\n```\\n\\n`rememberInject()` can be called inside Composable functions, but it is recommended to **use it as a default argument**.\\nThis will make it easier to replace during testing.\\n\\nPlease **do not to use the <Inject/> function inside Composable functions**. Creating an instance for each rendering or performing inject processing multiple times may cause performance degradation.\\n\\n```kotlin\\n@Composable\\nfun Sample(\\n    controller: SampleController = inject() // DO NOT!!\\n) {\\n    /* ... */\\n}\\n```\\n\\nFor the setup method, please refer to the [documentation](/docs/compose/core).\\n\\n## Component feature\\nIn ViewModel, you can inject a [`SavedStateHandle`](https://developer.android.com/reference/androidx/lifecycle/SavedStateHandle) to save the state:\\n\\n```kotlin\\n@Provides\\n@ViewModelComponent\\nclass SavedStateViewModel(\\n    private val savedStateHandle: SavedStateHandle\\n) : ViewModel() {\\n    /* ... */\\n}\\n```\\n\\nKoject has added the **Component feature** to provide instances created by the platform, such as `SavedStateHandle`.\\n\\nA Component is a grouping of types registered with the DI container.\\nBy default, the all types are registered in the root component.\\nBy annotating with a Component annotation, they can be registered in another component.\\n\\n```kotlin\\n// Registered in RootComponent\\n@Provides\\nclass NormalClass\\n\\n// Registered in SomeComponent\\n@SomeComponent\\n@Provides\\nclass ComponentClass\\n```\\n\\nTypes registered in a component can only reference types within the same component and types in the root component.\\n\\n![](/img/docs/component.png)\\n\\nYou can also provide additional dependencies to a component.\\n\\n![](/img/docs/component-extras.png)\\n\\nKoject defines `@ViewModelComponent` by default and adds `SavedStateHandle` to `@ViewModelComponent`.\\nTherefore, be aware that you cannot inject `SavedStateHandle` into a component other than `@ViewModelComponent`.\\n\\nYou can learn how to create a custom component in the [documentation](/docs/core/component).\\n\\n:::caution Experimental\\n\\nThe Component feature is an **experimental** API. It may change in the future.\\n\\n:::\\n\\n## Koject is evolving\\nI believe that Koject v1.1.0 will provide even stronger support for Android application development.\\nIn order to make the library even easier to use, I plan to add even more features in the future.\\n\\nIf you notice anything, please feel free to provide feedback on the [Issue](https://github.com/Mori-Atsushi/koject/issues) page."},{"id":"first-stable-release","metadata":{"permalink":"/koject/blog/first-stable-release","editUrl":"https://github.com/Mori-Atsushi/koject/tree/main/docs/blog/2023-03-04-first-stable-release.mdx","source":"@site/blog/2023-03-04-first-stable-release.mdx","title":"Hello, Koject v1.0.0","description":"I have recently released a new DI container library \\"Koject\\" for Kotlin Multiplatform.","date":"2023-03-04T00:00:00.000Z","formattedDate":"March 4, 2023","tags":[],"readingTime":5.795,"hasTruncateMarker":true,"authors":[{"name":"Mori Atsushi","title":"Koject owner","url":"https://github.com/Mori-Atsushi","imageURL":"https://github.com/mori-atsushi.png","key":"atsushi"}],"frontMatter":{"slug":"first-stable-release","title":"Hello, Koject v1.0.0","authors":"atsushi","image":"/blog/2023-03-04/ogp.png"},"prevItem":{"title":"Koject v1.1.0 - Enhanced Android support","permalink":"/koject/blog/android-support"}},"content":"![](/blog/2023-03-04/banner.png)\\n\\nI have recently released a new DI container library \\"**Koject**\\" for Kotlin Multiplatform.\\nIn this article, I will introduce the role of a DI container and the features of \\"**Koject**\\".\\n\\n\x3c!--truncate--\x3e\\n\\n[**\u65e5\u672c\u8a9e\u3067\u8aad\u3080 \u2192**](/blog/jp/first-stable-release)\\n\\n## Role of a DI Container\\nTo understand the role of a DI Container (Dependency Injection Container), we first need to know about Dependency Injection.\\n\\nDependency Injection is a technique that improves the testability and reusability of code by injecting dependencies from outside the class.\\n\\n### Improving Testability with Dependency Injection\\nLet\'s consider the example of a mobile app that uploads videos.\\nThe app selects a video from the local device, uploads it to a server, and displays a notification when the upload is complete.\\n\\nWe can implement the `VideoUploadService` using the `VideoUploader` class to upload the video and the `NotificationManager` class to display the notification as follows:\\n\\n```kotlin\\nclass VideoUploadService {\\n    fun upload(video: Video) {\\n        val result = VideoUploader().upload(video)\\n        if (result.isSucceeded) {\\n            NotificationManager()\\n                .showNotification(\\"Upload complete\\")\\n        } else {\\n            NotificationManager()\\n                .showNotification(\\"Upload failed\\")\\n        }\\n    }\\n}\\n```\\n\\nIn this implementation, the `VideoUploadService` class directly depends on the `VideoUploader` and `NotificationManager` classes, as it instantiates them.\\n\\nThe `VideoUploader` class communicates with the server, and the `NotificationManager` displays notifications on the device.\\nDepending directly on these external classes causes issues during testing, as it triggers communication with the external system, leading to instability and long testing times.\\n\\nDependency Injection suggests **passing these external dependencies from outside the class**.\\n\\nWe can rewrite the previous example using Dependency Injection as follows:\\n\\n```kotlin\\nclass VideoUploadService(\\n    private val videoUploader: VideoUpaloder,\\n    private val notificationManager: NotificationManager,\\n) {\\n    fun upload(video: Video) {\\n        val result = videoUploader.upload(video)\\n        if (result.isSucceeded) {\\n            notificationManager\\n                .showNotification(\\"Upload complete\\")\\n        } else {\\n            notificationManager\\n                .showNotification(\\"Upload failed\\")\\n        }\\n    }\\n}\\n```\\n\\nWe pass the necessary classes through the constructor.\\nThis technique is called **Constructor Injection**.\\n\\nThis way, we can write tests by substituting the real `VideoUploader` and `NotificationManager` classes with their fake counterparts, which do not communicate with the external system.\\n\\n```kotlin\\nclass VideoUploadServiceTest {\\n    private val videoUploader = \\n        FakeVideoUploader()\\n    private val notificationManager = \\n        FakeNotificationManager()\\n    private val videoUploadService =\\n        VideoUploadService(videoUploader, notificationManager)\\n\\n    @Test\\n    fun test() {\\n        val video = Video(\\"test.mp4\\")\\n        videoUploadService.upload(video)\\n        /* ... */\\n    }\\n}\\n```\\n\\nMoreover, following the Dependency Injection approach makes the relationships between classes more explicit. Even without reading the entire code, we can understand that **VideoUploadService** is related to **VideoUploader** and **NotificationManager** by merely looking at the constructor.\\n\\n### Improving Reusability with Dependency Injection\\nFrom the perspective of reusability, Dependency Injection is effective.\\n\\nWhen implementing the video upload application on both Android and iOS, the method of displaying notifications is different between the two platforms.\\nBy passing `NotificationManager` in the constructor, we only need to replace the `NotificationManager` for Android and iOS, and `VideoUploadService` can be used commonly.\\n\\n```kotlin\\n// for Android\\nval videoUploadService = VideoUploadService(\\n    videoUpaloder = VideoUpaloder(),\\n    notificationManager = AndroidNotificationManager(),\\n)\\n```\\n\\n```kotlin\\n// for iOS\\nval videoUploadService = VideoUploadService(\\n    videoUpaloder = VideoUpaloder(),\\n    notificationManager = IOSNotificationManager(),\\n)\\n```\\n\\nBy following the Dependency Injection pattern, **we can use the same code** for different platforms and use cases.\\n\\n### Consolidate Dependency Resolution with DI Containers\\n\\nAs mentioned earlier, Dependency Injection has several benefits. However, each class needs to specify all of its dependencies when used, and as the number of dependencies increases, creating instances becomes more difficult.\\n\\n```kotlin\\nval storageApi = StorageApi(Dispatchers.IO)\\nval videoUpaloder = VideoUpaloder(storageApi)\\nval notificationManager = NotificationManager(context)\\nval videoUploadService = VideoUploadService(\\n    videoUpaloder,\\n    notificationManager,\\n)\\n```\\n\\nThis is where DI containers come in handy. A DI container has the ability to automatically organize the necessary dependencies and create instances.\\n\\nWith Koject, we can register classes to the DI container by adding the `@Provides` annotation when declaring the class, and then use the `inject()` function to obtain an instance with resolved dependencies.\\n\\n```kotlin\\n@Provides\\nclass VideoUpaloder\\n\\n@Provides\\nclass NotificationManager\\n\\n@Provides\\nclass VideoUploadService(\\n    private val videoUploader: VideoUpaloder,\\n    private val notificationManager: NotificationManager,\\n) {\\n    /* ... */\\n}\\n```\\n```kotlin\\nKoject.start()\\n\\nval videoUploadService = inject<VideoUploadService>()\\n```\\n\\nBy using Koject, we can reap the benefits of Dependency Injection without writing complex code.\\n\\n## Features of Koject\\n\\nKoject is a new DI container library for Kotlin Multiplatform. Here are some of its main features.\\n\\n### Easy setup with annotations\\nKoject can be easily used with multiple annotations.\\n\\nBy adding the `@Provides` annotation to the class declaration, you can register it to the DI container.\\n\\n```kotlin\\n@Provides\\nclass Repository\\n\\n@Provides\\nclass Controller(\\n    private val repository: Repository\\n)\\n```\\n\\nAfter calling `Koject.start()`, you can obtain the instance of the registered class using the `inject()` method.\\n\\n```kotlin\\nfun main() {\\n    Koject.start()\\n\\n    val controller = inject<Controller>()\\n}\\n```\\n\\nIn this case, calling `inject<Controller>()` will create an instance of the `Controller` class using the primary constructor of Controller and the dependency with the `@Provides` annotation, which is provided by Koject.\\n\\n#### Provide as Singleton\\nBy adding the `@Singleton` annotation in addition to the `@Provides` annotation, you can limit the creation of instances to only once and reuse them throughout the application.\\nThis is especially useful for dependencies that are costly to create or that need to be shared among multiple classes.\\n\\n```kotlin\\n@Singleton\\n@Provides\\nclass Api\\n\\n@Singleton\\n@Provides\\nclass Repository(\\n    private val api: Api,\\n)\\n```\\n\\nIn this case, Koject will create only one instance of the `Api` class and `Repository`, and reuse them throughout the application.\\n\\n#### Provide as supertype\\nWhen practicing the DI pattern, the implementation class is often used as a superclass such as an interface.\\nWith Koject, you can easily provide it as a supertype by using the `@Binds` annotation.\\n\\nThe following example shows how to provide the `RepositoryImpl` as a `Repository` using the `@Binds` annotation.\\n\\n```kotlin\\n@Binds\\n@Provides\\nclass RepositoryImpl: Repository\\n\\ninterface Repository\\n```\\n\\n#### More details\\nFor more detailed usage, please refer to the [documentation](/docs/core/basic).\\n\\n### Support for Kotlin Multiplatform\\nKoject supports Kotlin Multiplatform, allowing you to create dependency graphs for each platform and even swap classes depending on the platform.\\n\\nCheck out the [setup instructions](/docs/setup) specific to each platform.\\n\\n### Checking the Dependency Graph at Compile Time\\nKoject works by generating code using [KSP](https://github.com/google/ksp).\\nThe dependency graph is generated at compile time, and if there are any missing dependencies or duplicate providers, the compile process will fail with an error. This helps prevent unexpected errors at runtime.\\n\\n```kotlin\\n// No @Provides annotation\\nclass Repository\\n\\n@Provides\\nclass Controller(\\n    private val repository: Repository\\n)\\n```\\n\\n![](/blog/2023-03-04/compile-error.png)\\n\\nNote that currently Koject does not check whether the class being called with `inject()` has been provided, which can lead to runtime errors like the following:\\n\\n```kotlin\\n// No @Provides annotation\\nclass SampleClass\\n\\nfun main() {\\n    Koject.start()\\n\\n    val controller = inject<SampleClass>() // NotProvidedException!!\\n}\\n```\\n\\n## Future Plans\\nKoject has just been born, and in order to make it a more convenient library, I plan to enhance the following support in the future:\\n\\n* Enhancing support for Android [#25](https://github.com/Mori-Atsushi/koject/issues/25) [#52](https://github.com/Mori-Atsushi/koject/issues/52)\\n* Enhancing support for testing [#85](https://github.com/Mori-Atsushi/koject/issues/85)\\n\\nIf you notice anything else, please send us your feedback on the [Issue page](https://github.com/Mori-Atsushi/koject/issues)."}]}')}}]);