"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[996],{5674:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"first-stable-release","metadata":{"permalink":"/koject/blog/first-stable-release","editUrl":"https://github.com/Mori-Atsushi/koject/tree/main/docs/blog/2023-03-04-first-stable-release.md","source":"@site/blog/2023-03-04-first-stable-release.md","title":"Hello, Koject v1.0.0","description":"I have recently released a new DI container library \\"Koject\\" for Kotlin Multiplatform.","date":"2023-03-04T00:00:00.000Z","formattedDate":"March 4, 2023","tags":[],"readingTime":5.795,"hasTruncateMarker":true,"authors":[{"name":"Mori Atsushi","title":"Koject owner","url":"https://github.com/Mori-Atsushi","imageURL":"https://github.com/mori-atsushi.png","key":"atsushi"}],"frontMatter":{"slug":"first-stable-release","title":"Hello, Koject v1.0.0","authors":"atsushi","image":"/blog/2023-03-04/ogp.png"}},"content":"![](/blog/2023-03-04/banner.png)\\n\\nI have recently released a new DI container library \\"**Koject**\\" for Kotlin Multiplatform.\\nIn this article, I will introduce the role of a DI container and the features of \\"**Koject**\\".\\n\\n\x3c!--truncate--\x3e\\n\\n[**\u65e5\u672c\u8a9e\u3067\u8aad\u3080 \u2192**](/blog/jp/first-stable-release)\\n\\n## Role of a DI Container\\nTo understand the role of a DI Container (Dependency Injection Container), we first need to know about Dependency Injection.\\n\\nDependency Injection is a technique that improves the testability and reusability of code by injecting dependencies from outside the class.\\n\\n### Improving Testability with Dependency Injection\\nLet\'s consider the example of a mobile app that uploads videos.\\nThe app selects a video from the local device, uploads it to a server, and displays a notification when the upload is complete.\\n\\nWe can implement the `VideoUploadService` using the `VideoUploader` class to upload the video and the `NotificationManager` class to display the notification as follows:\\n\\n```kotlin\\nclass VideoUploadService {\\n    fun upload(video: Video) {\\n        val result = VideoUploader().upload(video)\\n        if (result.isSucceeded) {\\n            NotificationManager()\\n                .showNotification(\\"Upload complete\\")\\n        } else {\\n            NotificationManager()\\n                .showNotification(\\"Upload failed\\")\\n        }\\n    }\\n}\\n```\\n\\nIn this implementation, the `VideoUploadService` class directly depends on the `VideoUploader` and `NotificationManager` classes, as it instantiates them.\\n\\nThe `VideoUploader` class communicates with the server, and the `NotificationManager` displays notifications on the device.\\nDepending directly on these external classes causes issues during testing, as it triggers communication with the external system, leading to instability and long testing times.\\n\\nDependency Injection suggests **passing these external dependencies from outside the class**.\\n\\nWe can rewrite the previous example using Dependency Injection as follows:\\n\\n```kotlin\\nclass VideoUploadService(\\n    private val videoUploader: VideoUpaloder,\\n    private val notificationManager: NotificationManager,\\n) {\\n    fun upload(video: Video) {\\n        val result = videoUploader.upload(video)\\n        if (result.isSucceeded) {\\n            notificationManager\\n                .showNotification(\\"Upload complete\\")\\n        } else {\\n            notificationManager\\n                .showNotification(\\"Upload failed\\")\\n        }\\n    }\\n}\\n```\\n\\nWe pass the necessary classes through the constructor.\\nThis technique is called **Constructor Injection**.\\n\\nThis way, we can write tests by substituting the real `VideoUploader` and `NotificationManager` classes with their fake counterparts, which do not communicate with the external system.\\n\\n```kotlin\\nclass VideoUploadServiceTest {\\n    private val videoUploader = \\n        FakeVideoUploader()\\n    private val notificationManager = \\n        FakeNotificationManager()\\n    private val videoUploadService =\\n        VideoUploadService(videoUploader, notificationManager)\\n\\n    @Test\\n    fun test() {\\n        val video = Video(\\"test.mp4\\")\\n        videoUploadService.upload(video)\\n        /* ... */\\n    }\\n}\\n```\\n\\nMoreover, following the Dependency Injection approach makes the relationships between classes more explicit. Even without reading the entire code, we can understand that **VideoUploadService** is related to **VideoUploader** and **NotificationManager** by merely looking at the constructor.\\n\\n### Improving Reusability with Dependency Injection\\nFrom the perspective of reusability, Dependency Injection is effective.\\n\\nWhen implementing the video upload application on both Android and iOS, the method of displaying notifications is different between the two platforms.\\nBy passing `NotificationManager` in the constructor, we only need to replace the `NotificationManager` for Android and iOS, and `VideoUploadService` can be used commonly.\\n\\n```kotlin\\n// for Android\\nval videoUploadService = VideoUploadService(\\n    videoUpaloder = VideoUpaloder(),\\n    notificationManager = AndroidNotificationManager(),\\n)\\n```\\n\\n```kotlin\\n// for iOS\\nval videoUploadService = VideoUploadService(\\n    videoUpaloder = VideoUpaloder(),\\n    notificationManager = IOSNotificationManager(),\\n)\\n```\\n\\nBy following the Dependency Injection pattern, **we can use the same code** for different platforms and use cases.\\n\\n### Consolidate Dependency Resolution with DI Containers\\n\\nAs mentioned earlier, Dependency Injection has several benefits. However, each class needs to specify all of its dependencies when used, and as the number of dependencies increases, creating instances becomes more difficult.\\n\\n```kotlin\\nval storageApi = StorageApi(Dispatchers.IO)\\nval videoUpaloder = VideoUpaloder(storageApi)\\nval notificationManager = NotificationManager(context)\\nval videoUploadService = VideoUploadService(\\n    videoUpaloder,\\n    notificationManager,\\n)\\n```\\n\\nThis is where DI containers come in handy. A DI container has the ability to automatically organize the necessary dependencies and create instances.\\n\\nWith Koject, we can register classes to the DI container by adding the `@Provides` annotation when declaring the class, and then use the `inject()` function to obtain an instance with resolved dependencies.\\n\\n```kotlin\\n@Provides\\nclass VideoUpaloder\\n\\n@Provides\\nclass NotificationManager\\n\\n@Provides\\nclass VideoUploadService(\\n    private val videoUploader: VideoUpaloder,\\n    private val notificationManager: NotificationManager,\\n) {\\n    /* ... */\\n}\\n```\\n```kotlin\\nKoject.start()\\n\\nval videoUploadService = inject<VideoUploadService>()\\n```\\n\\nBy using Koject, we can reap the benefits of Dependency Injection without writing complex code.\\n\\n## Features of Koject\\n\\nKoject is a new DI container library for Kotlin Multiplatform. Here are some of its main features.\\n\\n### Easy setup with annotations\\nKoject can be easily used with multiple annotations.\\n\\nBy adding the `@Provides` annotation to the class declaration, you can register it to the DI container.\\n\\n```kotlin\\n@Provides\\nclass Repository\\n\\n@Provides\\nclass Controller(\\n    private val repository: Repository\\n)\\n```\\n\\nAfter calling `Koject.start()`, you can obtain the instance of the registered class using the `inject()` method.\\n\\n```kotlin\\nfun main() {\\n    Koject.start()\\n\\n    val controller = inject<Controller>()\\n}\\n```\\n\\nIn this case, calling `inject<Controller>()` will create an instance of the `Controller` class using the primary constructor of Controller and the dependency with the `@Provides` annotation, which is provided by Koject.\\n\\n#### Provide as Singleton\\nBy adding the `@Singleton` annotation in addition to the `@Provides` annotation, you can limit the creation of instances to only once and reuse them throughout the application.\\nThis is especially useful for dependencies that are costly to create or that need to be shared among multiple classes.\\n\\n```kotlin\\n@Singleton\\n@Provides\\nclass Api\\n\\n@Singleton\\n@Provides\\nclass Repository(\\n    private val api: Api,\\n)\\n```\\n\\nIn this case, Koject will create only one instance of the `Api` class and `Repository`, and reuse them throughout the application.\\n\\n#### Provide as supertype\\nWhen practicing the DI pattern, the implementation class is often used as a superclass such as an interface.\\nWith Koject, you can easily provide it as a supertype by using the `@Binds` annotation.\\n\\nThe following example shows how to provide the `RepositoryImpl` as a `Repository` using the `@Binds` annotation.\\n\\n```kotlin\\n@Binds\\n@Provides\\nclass RepositoryImpl: Repository\\n\\ninterface Repository\\n```\\n\\n#### More details\\nFor more detailed usage, please refer to the [documentation](/docs/usage).\\n\\n### Support for Kotlin Multiplatform\\nKoject supports Kotlin Multiplatform, allowing you to create dependency graphs for each platform and even swap classes depending on the platform.\\n\\nCheck out the [setup instructions](/docs/setup) specific to each platform.\\n\\n### Checking the Dependency Graph at Compile Time\\nKoject works by generating code using [KSP](https://github.com/google/ksp).\\nThe dependency graph is generated at compile time, and if there are any missing dependencies or duplicate providers, the compile process will fail with an error. This helps prevent unexpected errors at runtime.\\n\\n```kotlin\\n// No @Provides annotation\\nclass Repository\\n\\n@Provides\\nclass Controller(\\n    private val repository: Repository\\n)\\n```\\n\\n![](/blog/2023-03-04/compile-error.png)\\n\\nNote that currently Koject does not check whether the class being called with `inject()` has been provided, which can lead to runtime errors like the following:\\n\\n```kotlin\\n// No @Provides annotation\\nclass SampleClass\\n\\nfun main() {\\n    Koject.start()\\n\\n    val controller = inject<SampleClass>() // NotProvidedException!!\\n}\\n```\\n\\n## Future Plans\\nKoject has just been born, and in order to make it a more convenient library, I plan to enhance the following support in the future:\\n\\n* Enhancing support for Android [#25](https://github.com/Mori-Atsushi/koject/issues/25) [#52](https://github.com/Mori-Atsushi/koject/issues/52)\\n* Enhancing support for testing [#85](https://github.com/Mori-Atsushi/koject/issues/85)\\n\\nIf you notice anything else, please send us your feedback on the [Issue page](https://github.com/Mori-Atsushi/koject/issues)."}]}')}}]);